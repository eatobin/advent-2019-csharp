namespace App

open System.Text

type Memory = Map<int, int>
type Instruction = Map<char, int>
type IntCode = { pointer: int; memory: Memory }
type Index = int
type Value = int

// Instruction:
// ABCDE
// 01234
// 01002
// 34(DE) - two-digit opcode,      02 == opcode 2
//  2(C) - mode of 1st parameter,  0 == position mode
//  1(B) - mode of 2nd parameter,  1 == immediate mode
//  0(A) - mode of 3rd parameter,  0 == position mode,
//                                   omitted due to being a leading zero
// 0 1 or 2 = left-to-right position after 2 digit opcode
// p i or r = position, immediate or relative mode
// r or w = read or write

module Intcode =
    let memoryAsList =
        [ 1
          0
          0
          3
          1
          1
          2
          3
          1
          3
          4
          3
          1
          5
          0
          3
          2
          10
          1
          19
          2
          9
          19
          23
          2
          13
          23
          27
          1
          6
          27
          31
          2
          6
          31
          35
          2
          13
          35
          39
          1
          39
          10
          43
          2
          43
          13
          47
          1
          9
          47
          51
          1
          51
          13
          55
          1
          55
          13
          59
          2
          59
          13
          63
          1
          63
          6
          67
          2
          6
          67
          71
          1
          5
          71
          75
          2
          6
          75
          79
          1
          5
          79
          83
          2
          83
          6
          87
          1
          5
          87
          91
          1
          6
          91
          95
          2
          95
          6
          99
          1
          5
          99
          103
          1
          6
          103
          107
          1
          107
          2
          111
          1
          111
          5
          0
          99
          2
          14
          0
          0 ]

    let offsetC: int = 1
    let offsetB: int = 2
    let offsetA: int = 3

    let makeMemoryMap () : Memory =
        let keys: int list = [ 0 .. (memoryAsList.Length - 1) ]
        List.zip keys memoryAsList |> Map.ofList

    let charToInt (aChar: byte) : int =
        if (aChar < 48uy || aChar > 57uy) then
            raise (System.ArgumentException("Char is not an integer"))
        else
            int (aChar - 48uy)

    let pad5 (op: int) : Instruction =
        let values = Encoding.ASCII.GetBytes $"%05i{op}" |> Array.map charToInt

        let keys = [| 'a'; 'b'; 'c'; 'd'; 'e' |]
        Array.zip keys values |> Map.ofArray

    let writeToReadFromIndex (intcode: IntCode) (offset: int) : Index =
        intcode.memory
        |> Map.tryFind (intcode.pointer + offset)
        |> Option.defaultValue 0

    let pw (intcode: IntCode) (offset: int) : Index = writeToReadFromIndex intcode offset

    let pr (intcode: IntCode) (offset: int) : Value =
        intcode.memory |> Map.find (writeToReadFromIndex intcode offset)

    let aParam (instruction: Instruction) (intcode: IntCode) : Index =
        match instruction['a'] with
        | 0 -> pw intcode offsetA // a-p-w
        | _ -> raise (System.ArgumentException("Instruction is not valid"))

    let bParam (instruction: Instruction) (intcode: IntCode) : Value =
        match instruction['b'] with
        | 0 -> pr intcode offsetB // b-p-r
        | _ -> raise (System.ArgumentException("Instruction is not valid"))

    let cParam (instruction: Instruction) (intcode: IntCode) : Value =
        match instruction['c'] with
        | 0 -> pr intcode offsetC // c-p-r
        | _ -> raise (System.ArgumentException("Instruction is not valid"))

    let add (instruction: Instruction) (intCode: IntCode) : IntCode =
        { pointer = intCode.pointer + 4
          memory =
            intCode.memory
            |> Map.add (aParam instruction intCode) ((cParam instruction intCode) + (bParam instruction intCode)) }

    let multiply (instruction: Instruction) (intCode: IntCode) : IntCode =
        { pointer = intCode.pointer + 4
          memory =
            intCode.memory
            |> Map.add (aParam instruction intCode) ((cParam instruction intCode) * (bParam instruction intCode)) }

    [<TailCall>]
    let rec opCode (intCode: IntCode) : IntCode =
        let instruction: Instruction = pad5 intCode.memory[intCode.pointer]

        match instruction['e'] with
        | 1 -> opCode (add instruction intCode)
        | 2 -> opCode (multiply instruction intCode)
        | 9 -> intCode
        | _ -> raise (System.ArgumentException("Instruction is not valid"))

module Program =
    do
        let memory: Memory = Intcode.makeMemoryMap ()

        let updatedMemory (noun: int) (verb: int) : Memory =
            memory |> Map.add 1 noun |> Map.add 2 verb

        let ic: IntCode =
            Intcode.opCode
                { pointer = 0
                  memory = updatedMemory 12 2 }

        let answer = ic.memory[0]

        printfn $"\nPart A: %i{answer}, correct: 2890696"

        let answer2: int =
            [ for noun: int in 0..99 do
                  for verb: int in 0..99 do
                      let candidate: int =
                          (Intcode.opCode
                              { pointer = 0
                                memory = updatedMemory noun verb })
                              .memory[0]

                      if (candidate = 19_690_720) then
                          yield (100 * noun) + verb ]
                .Head

        printfn $"Part B: %i{answer2}, correct: 8226\n"
